const { cmd, commands } = require("../command");
const { sleep } = require("../lib/functions");
const config = require("../config");

// 2. FING Command
cmd({
    pattern: "fing",
    alias: ['fingering', 'hath', 'ungli', 'touch', 'moan'],
    desc: "Funny girl animation (owner only)",
    category: "tools",
    react: "üëÖ",
    filename: __filename
}, async (conn, mek, m, { from, reply, isCreator }) => {
    try {
        if (!isCreator) {
            return await conn.sendMessage(from, { text: "*This is an owner command.*" }, { quoted: mek });
        }

        const animationFrames = [
            "üëÜüèª------üçë", 
            "üëÜüèª-----üçë", 
            "üëÜüèª----üçë", 
            "üëÜüèª---üçë", 
            "üëÜüèª--üçë", 
            "üëÜüèª-üçë", 
            "üëÜüèªüçë", 
            "üëâüèªüçë", 
            "üëâüèªüí¶üçë", 
            "üëâüèªüí¶üí¶üçë", 
            "üëâüèªüí¶üí¶üí¶üçë", 
            "üí¶üçëüí¶ *Awf ü•µüëÖ*"
        ];

        let currentText = '';
        const sentMessage = await conn.sendMessage(from, { text: currentText }, { quoted: mek });

        for (const frame of animationFrames) {
            currentText = frame;
            await sleep(1000);
            const protocolMsg = {
                key: sentMessage.key,
                type: 0xe,
                editedMessage: { conversation: currentText }
            };
            await conn.relayMessage(from, { protocolMessage: protocolMsg }, {});
        }
    } catch (e) {
        reply(`‚ùå *Error!* ${e.message}`);
    }
});

// 3. MUTH Command
cmd({
    pattern: "muth",
    alias: ["handjob", "hand"],
    desc: "Displays a simple handjob animation (owner only)",
    category: "fun",
    react: "‚úä",
    filename: __filename
}, async (conn, mek, m, { from, reply, isCreator }) => {
    try {
        if (!isCreator) {
            return await conn.sendMessage(from, { text: "*This is an owner command.*" }, { quoted: mek });
        }

        const animationFrames = [
            "‚úä üçå",
            "‚úäüçå",
            "‚úäüçåüí¶",
            "‚úäüçåüí¶üí¶",
            "üò©üí¶üí¶üí¶",
            "üòµ‚Äçüí´ Done!"
        ];

        let currentText = '';
        const sentMessage = await conn.sendMessage(from, { text: currentText }, { quoted: mek });

        for (const frame of animationFrames) {
            currentText = frame;
            await sleep(800);
            const protocolMsg = {
                key: sentMessage.key,
                type: 0xe,
                editedMessage: { conversation: currentText }
            };
            await conn.relayMessage(from, { protocolMessage: protocolMsg }, {});
        }
    } catch (e) {
        reply(`‚ùå Error: ${e.message}`);
    }
});

// 4. HAPPY Command
cmd({
    pattern: "happy",
    desc: "Displays a dynamic edit msg for fun.",
    category: "tools",
    react: "üòÇ",
    filename: __filename
}, async (conn, mek, m, { from, reply, isCreator }) => {
    try {
        if (!isCreator) {
            return await conn.sendMessage(from, { text: "*This is an owner command.*" }, { quoted: mek });
        }

        const emojiMessages = [
            "üòÉ", "üòÑ", "üòÅ", "üòä", "üòé", "ü•≥",
            "üò∏", "üòπ", "üåû", "üåà", "üòÉ", "üòÑ",
            "üòÅ", "üòä", "üòé", "ü•≥", "üò∏", "üòπ",
            "üåû", "üåà", "üòÉ", "üòÑ", "üòÅ", "üòä"
        ];

        let currentText = '';
        const sentMessage = await conn.sendMessage(from, { text: currentText }, { quoted: mek });

        for (const line of emojiMessages) {
            currentText = line;
            await sleep(1000);
            const protocolMsg = {
                key: sentMessage.key,
                type: 0xe,
                editedMessage: { conversation: currentText }
            };
            await conn.relayMessage(from, { protocolMessage: protocolMsg }, {});
        }
    } catch (e) {
        reply(`‚ùå *Error!* ${e.message}`);
    }
});

// 5. HEART Command
cmd({
    pattern: "heart",
    desc: "Displays a dynamic edit msg for fun.",
    category: "tools",
    react: "‚ù§Ô∏è",
    filename: __filename
}, async (conn, mek, m, { from, reply, isCreator }) => {
    try {
        if (!isCreator) {
            return await conn.sendMessage(from, { text: "*This is an owner command.*" }, { quoted: mek });
        }

        const emojiMessages = [
            "üíñ", "üíó", "üíï", "ü©∑", "üíõ", "üíö",
            "ü©µ", "üíô", "üíú", "üñ§", "ü©∂", "ü§ç",
            "ü§é", "‚ù§Ô∏è‚Äçüî•", "üíû", "üíì", "üíò", "üíù",
            "‚ô•Ô∏è", "üíü", "‚ù§Ô∏è‚Äçü©π", "‚ù§Ô∏è"
        ];

        let currentText = '';
        const sentMessage = await conn.sendMessage(from, { text: currentText }, { quoted: mek });

        for (const line of emojiMessages) {
            currentText = line;
            await sleep(1000);
            const protocolMsg = {
                key: sentMessage.key,
                type: 0xe,
                editedMessage: { conversation: currentText }
            };
            await conn.relayMessage(from, { protocolMessage: protocolMsg }, {});
        }
    } catch (e) {
        reply(`‚ùå *Error!* ${e.message}`);
    }
});

// 6. ANGRY Command
cmd({
    pattern: "angry",
    desc: "Displays a dynamic edit msg for fun.",
    category: "tools",
    react: "ü§°",
    filename: __filename
}, async (conn, mek, m, { from, reply, isCreator }) => {
    try {
        if (!isCreator) {
            return await conn.sendMessage(from, { text: "*This is an owner command.*" }, { quoted: mek });
        }

        const emojiMessages = [
            "üò°", "üò†", "ü§¨", "üò§", "üòæ", "üò°",
            "üò†", "ü§¨", "üò§", "üòæ"
        ];

        let currentText = '';
        const sentMessage = await conn.sendMessage(from, { text: currentText }, { quoted: mek });

        for (const line of emojiMessages) {
            currentText = line;
            await sleep(1000);
            const protocolMsg = {
                key: sentMessage.key,
                type: 0xe,
                editedMessage: { conversation: currentText }
            };
            await conn.relayMessage(from, { protocolMessage: protocolMsg }, {});
        }
    } catch (e) {
        reply(`‚ùå *Error!* ${e.message}`);
    }
});

// 7. SAD Command
cmd({
    pattern: "sad",
    desc: "Displays a dynamic edit msg for fun.",
    category: "tools",
    react: "üò∂",
    filename: __filename
}, async (conn, mek, m, { from, reply, isCreator }) => {
    try {
        if (!isCreator) {
            return await conn.sendMessage(from, { text: "*This is an owner command.*" }, { quoted: mek });
        }

        const emojiMessages = [
            "ü•∫", "üòü", "üòï", "üòñ", "üò´", "üôÅ",
            "üò©", "üò•", "üòì", "üò™", "üò¢", "üòî",
            "üòû", "üò≠", "üíî", "üò≠", "üòø"
        ];

        let currentText = '';
        const sentMessage = await conn.sendMessage(from, { text: currentText }, { quoted: mek });

        for (const line of emojiMessages) {
            currentText = line;
            await sleep(1000);
            const protocolMsg = {
                key: sentMessage.key,
                type: 0xe,
                editedMessage: { conversation: currentText }
            };
            await conn.relayMessage(from, { protocolMessage: protocolMsg }, {});
        }
    } catch (e) {
        reply(`‚ùå *Error!* ${e.message}`);
    }
});

// 8. SHY Command
cmd({
    pattern: "shy",
    desc: "Displays a dynamic edit msg for fun.",
    category: "tools",
    react: "üßê",
    filename: __filename
}, async (conn, mek, m, { from, reply, isCreator }) => {
    try {
        if (!isCreator) {
            return await conn.sendMessage(from, { text: "*This is an owner command.*" }, { quoted: mek });
        }

        const emojiMessages = [
            "üò≥", "üòä", "üò∂", "üôà", "üôä",
            "üò≥", "üòä", "üò∂", "üôà", "üôä"
        ];

        let currentText = '';
        const sentMessage = await conn.sendMessage(from, { text: currentText }, { quoted: mek });

        for (const line of emojiMessages) {
            currentText = line;
            await sleep(1000);
            const protocolMsg = {
                key: sentMessage.key,
                type: 0xe,
                editedMessage: { conversation: currentText }
            };
            await conn.relayMessage(from, { protocolMessage: protocolMsg }, {});
        }
    } catch (e) {
        reply(`‚ùå *Error!* ${e.message}`);
    }
});

// 9. MOON Command
cmd({
    pattern: "moon",
    desc: "Displays a dynamic edit msg for fun.",
    category: "tools",
    react: "üåö",
    filename: __filename
}, async (conn, mek, m, { from, reply, isCreator }) => {
    try {
        if (!isCreator) {
            return await conn.sendMessage(from, { text: "*This is an owner command.*" }, { quoted: mek });
        }

        const emojiMessages = [
            "üåó", "üåò", "üåë", "üåí", "üåì", "üåî",
            "üåï", "üåñ", "üåó", "üåò", "üåë", "üåí",
            "üåì", "üåî", "üåï", "üåñ", "üåó", "üåò",
            "üåë", "üåí", "üåì", "üåî", "üåï", "üåñ",
            "üåó", "üåò", "üåë", "üåí", "üåì", "üåî",
            "üåï", "üåñ", "üåùüåö"
        ];

        let currentText = '';
        const sentMessage = await conn.sendMessage(from, { text: currentText }, { quoted: mek });

        for (const line of emojiMessages) {
            currentText = line;
            await sleep(1000);
            const protocolMsg = {
                key: sentMessage.key,
                type: 0xe,
                editedMessage: { conversation: currentText }
            };
            await conn.relayMessage(from, { protocolMessage: protocolMsg }, {});
        }
    } catch (e) {
        reply(`‚ùå *Error!* ${e.message}`);
    }
});

// 10. CONFUSED Command
cmd({
    pattern: "confused",
    desc: "Displays a dynamic edit msg for fun.",
    category: "tools",
    react: "ü§î",
    filename: __filename
}, async (conn, mek, m, { from, reply, isCreator }) => {
    try {
        if (!isCreator) {
            return await conn.sendMessage(from, { text: "*This is an owner command.*" }, { quoted: mek });
        }

        const emojiMessages = [
            "üòï", "üòü", "üòµ", "ü§î", "üòñ", 
            "üò≤", "üò¶", "ü§∑", "ü§∑‚Äç‚ôÇÔ∏è", "ü§∑‚Äç‚ôÄÔ∏è"
        ];

        let currentText = '';
        const sentMessage = await conn.sendMessage(from, { text: currentText }, { quoted: mek });

        for (const line of emojiMessages) {
            currentText = line;
            await sleep(1000);
            const protocolMsg = {
                key: sentMessage.key,
                type: 0xe,
                editedMessage: { conversation: currentText }
            };
            await conn.relayMessage(from, { protocolMessage: protocolMsg }, {});
        }
    } catch (e) {
        reply(`‚ùå *Error!* ${e.message}`);
    }
});

// 11. NIKAL Command
cmd({
    pattern: "nikal",
    desc: "Displays a dynamic edit msg for fun.",
    category: "tools",
    react: "üóø",
    filename: __filename
}, async (conn, mek, m, { from, reply, isCreator }) => {
    try {
        if (!isCreator) {
            return await conn.sendMessage(from, { text: "*This is an owner command.*" }, { quoted: mek });
        }

        const asciiMessages = [
            "‚†Ä‚†Ä‚†Ä‚£†‚£∂‚°æ‚†è‚†â‚†ô‚†≥‚¢¶‚°Ä‚†Ä‚†Ä‚†Ä‚¢†‚†û‚†â‚†ô‚†≤‚°Ä‚†Ä\n ‚†Ä‚£¥‚†ø‚†è‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä     ‚¢≥‚°Ä‚†Ä‚°è‚†Ä‚†Ä‚†Ä   ‚†Ä  ‚¢∑\n‚¢†‚£ü‚£ã‚°Ä‚¢Ä‚£Ä‚£Ä‚°Ä‚†Ä‚£Ä‚°Ä   ‚£ß‚†Ä‚¢∏‚†Ä‚†Ä‚†Ä  ‚†Ä    ‚°á\n‚¢∏‚£Ø‚°≠‚†Å‚†∏‚£õ‚£ü‚†Ü‚°¥‚£ª‚°≤     ‚£ø  ‚£∏   Nikal   ‚°á\n ‚£ü‚£ø‚°≠‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢±‚†Ä‚†Ä      ‚£ø  ‚¢π‚†Ä          ‚°á\n  ‚†ô‚¢ø‚£Ø‚†Ñ‚†Ä‚†Ä__‚†Ä   ‚†Ä   ‚°ø ‚†Ä‚°á‚†Ä‚†Ä‚†Ä‚†Ä    ‚°º\n‚†Ä‚†Ä‚†Ä‚†π‚£∂‚†Ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°¥‚†É‚†Ä   ‚†ò‚†§‚£Ñ‚£†‚†û‚†Ä\n‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£∑‚°¶‚¢§‚°§‚¢§‚£û‚£Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\n‚†Ä‚¢Ä‚£§‚£¥‚£ø‚£è‚†Å‚†Ä‚†Ä‚†∏‚£è‚¢Ø‚£∑‚£ñ‚£¶‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\n‚¢Ä‚£æ‚£Ω‚£ø‚£ø‚£ø‚£ø‚†õ‚¢≤‚£∂‚£æ‚¢â‚°∑‚£ø‚£ø‚†µ‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\n‚£º‚£ø‚†ç‚†â‚£ø‚°≠‚†â‚†ô‚¢∫‚£á‚£º‚°è‚†Ä‚†Ä ‚†Ä‚£Ñ‚¢∏‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä",
            "‚†Ä‚†Ä‚†Ä‚£†‚£∂‚°æ‚†è‚†â‚†ô‚†≥‚¢¶‚°Ä‚†Ä‚†Ä‚†Ä‚¢†‚†û‚†â‚†ô‚†≤‚°Ä‚†Ä\n ‚†Ä‚£¥‚†ø‚†è‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä  ‚†Ä  ‚¢≥‚°Ä‚†Ä‚°è‚†Ä‚†Ä‚†Ä   ‚†Ä  ‚¢∑\n‚¢†‚£ü‚£ã‚°Ä‚¢Ä‚£Ä‚£Ä‚°Ä‚†Ä‚£Ä‚°Ä   ‚£ß‚†Ä‚¢∏‚†Ä‚†Ä‚†Ä       ‚°á\n‚¢∏‚£Ø‚°≠‚†Å‚†∏‚£õ‚£ü‚†Ü‚°¥‚£ª‚°≤     ‚£ø  ‚£∏   Lavde   ‚°á\n ‚£ü‚£ø‚°≠‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢±‚†Ä‚†Ä      ‚£ø  ‚¢π‚†Ä          ‚°á\n  ‚†ô‚¢ø‚£Ø‚†Ñ‚†Ä‚†Ä|__|‚†Ä‚†Ä   ‚°ø ‚†Ä‚°á‚†Ä‚†Ä‚†Ä‚†Ä    ‚°º\n‚†Ä‚†Ä‚†Ä‚†π‚£∂‚†Ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°¥‚†É‚†Ä   ‚†ò‚†§‚£Ñ‚£†‚†û‚†Ä\n‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£∑‚°¶‚¢§‚°§‚¢§‚£û‚£Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\n‚†Ä‚¢Ä‚£§‚£¥‚£ø‚£è‚†Å‚†Ä‚†Ä‚†∏‚£è‚¢Ø‚£∑‚£ñ‚£¶‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\n‚¢Ä‚£æ‚£Ω‚£ø‚£ø‚£ø‚£ø‚†õ‚¢≤‚£∂‚£æ‚¢â‚°∑‚£ø‚£ø‚†µ‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\n‚£º‚£ø‚†ç‚†â‚£ø‚°≠‚†â‚†ô‚¢∫‚£á‚£º‚°è‚†Ä‚†Ä ‚†Ä‚£Ñ‚¢∏‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä",
            "‚†Ä‚†Ä‚†Ä‚£†‚£∂‚°æ‚†è‚†â‚†ô‚†≥‚¢¶‚°Ä‚†Ä‚†Ä‚†Ä‚¢†‚†û‚†â‚†ô‚†≤‚°Ä‚†Ä\n ‚†Ä‚£¥‚†ø‚†è‚†Ä‚†Ä     ‚†Ä   ‚¢≥‚°Ä‚†Ä‚°è‚†Ä‚†Ä    ‚†Ä  ‚¢∑\n‚¢†‚£ü‚£ã‚°Ä‚¢Ä‚£Ä‚£Ä‚°Ä‚†Ä‚£Ä‚°Ä   ‚£ß‚†Ä‚¢∏‚†Ä‚†Ä‚†Ä‚†Ä      ‚°á\n‚¢∏‚£Ø‚°≠‚†Å‚†∏‚£õ‚£ü‚†Ü‚°¥‚£ª‚°≤    ‚£ø  ‚£∏   Pehli   ‚°á\n ‚£ü‚£ø‚°≠‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢±‚†Ä‚†Ä     ‚£ø  ‚¢π‚†Ä           ‚°á\n  ‚†ô‚¢ø‚£Ø‚†Ñ‚†Ä‚†Ä(P)‚†Ä‚†Ä     ‚°ø ‚†Ä‚°á‚†Ä‚†Ä‚†Ä‚†Ä    ‚°º\n‚†Ä‚†Ä‚†Ä‚†π‚£∂‚†Ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°¥‚†É‚†Ä   ‚†ò‚†§‚£Ñ‚£†‚†û‚†Ä\n‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£∑‚°¶‚¢§‚°§‚¢§‚£û‚£Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\n‚†Ä‚¢Ä‚£§‚£¥‚£ø‚£è‚†Å‚†Ä‚†Ä‚†∏‚£è‚¢Ø‚£∑‚£ñ‚£¶‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\n‚¢Ä‚£æ‚£Ω‚£ø‚£ø‚£ø‚£ø‚†õ‚¢≤‚£∂‚£æ‚¢â‚°∑‚£ø‚£ø‚†µ‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\n‚£º‚£ø‚†ç‚†â‚£ø‚°≠‚†â‚†ô‚¢∫‚£á‚£º‚°è‚†Ä‚†Ä ‚†Ä‚£Ñ‚¢∏‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä",
            "‚†Ä‚†Ä‚†Ä‚£†‚£∂‚°æ‚†è‚†â‚†ô‚†≥‚¢¶‚°Ä‚†Ä‚†Ä‚†Ä‚¢†‚†û‚†â‚†ô‚†≤‚°Ä‚†Ä\n ‚†Ä‚£¥‚†ø‚†è‚†Ä‚†Ä     ‚†Ä   ‚¢≥‚°Ä‚†Ä‚°è‚†Ä‚†Ä    ‚†Ä  ‚¢∑\n‚¢†‚£ü‚£ã‚°Ä‚¢Ä‚£Ä‚£Ä‚°Ä‚†Ä‚£Ä‚°Ä   ‚£ß‚†Ä‚¢∏‚†Ä   ‚†Ä     ‚°á\n‚¢∏‚£Ø‚°≠‚†Å‚†∏‚£õ‚£ü‚†Ü‚°¥‚£ª‚°≤    ‚£ø  ‚£∏  Fursat  ‚°á\n ‚£ü‚£ø‚°≠‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢±‚†Ä        ‚£ø  ‚¢π‚†Ä          ‚°á\n  ‚†ô‚¢ø‚£Ø‚†Ñ‚†Ä‚†Ä‚†Ä__ ‚†Ä  ‚†Ä   ‚°ø ‚†Ä‚°á‚†Ä‚†Ä‚†Ä‚†Ä    ‚°º\n‚†Ä‚†Ä‚†Ä‚†π‚£∂‚†Ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°¥‚†É‚†Ä   ‚†ò‚†§‚£Ñ‚£†‚†û‚†Ä\n‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£∑‚°¶‚¢§‚°§‚¢§‚£û‚£Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\n‚†Ä‚¢Ä‚£§‚£¥‚£ø‚£è‚†Å‚†Ä‚†Ä‚†∏‚£è‚¢Ø‚£∑‚£ñ‚£¶‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\n‚¢Ä‚£æ‚£Ω‚£ø‚£ø‚£ø‚£ø‚†õ‚¢≤‚£∂‚£æ‚¢â‚°∑‚£ø‚£ø‚†µ‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\n‚£º‚£ø‚†ç‚†â‚£ø‚°≠‚†â‚†ô‚¢∫‚£á‚£º‚°è‚†Ä‚†Ä ‚†Ä‚£Ñ‚¢∏‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä",
            "‚†Ä‚†Ä‚†Ä‚£†‚£∂‚°æ‚†è‚†â‚†ô‚†≥‚¢¶‚°Ä‚†Ä‚†Ä‚†Ä‚¢†‚†û‚†â‚†ô‚†≤‚°Ä‚†Ä\n ‚†Ä‚£¥‚†ø‚†è‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä      ‚¢≥‚°Ä‚†Ä‚°è‚†Ä‚†Ä    ‚†Ä  ‚¢∑\n‚¢†‚£ü‚£ã‚°Ä‚¢Ä‚£Ä‚£Ä‚°Ä‚†Ä‚£Ä‚°Ä   ‚£ß‚†Ä‚¢∏‚†Ä‚†Ä ‚†Ä      ‚°á\n‚¢∏‚£Ø‚°≠‚†Å‚†∏‚£õ‚£ü‚†Ü‚°¥‚£ª‚°≤    ‚£ø  ‚£∏  Meeee   ‚°á\n ‚£ü‚£ø‚°≠‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢±‚†Ä‚†Ä       ‚£ø  ‚¢π‚†Ä          ‚°á\n  ‚†ô‚¢ø‚£Ø‚†Ñ‚†Ä‚†Ä|__| ‚†Ä    ‚°ø ‚†Ä‚°á‚†Ä‚†Ä‚†Ä‚†Ä    ‚°º\n‚†Ä‚†Ä‚†Ä‚†π‚£∂‚†Ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°¥‚†É‚†Ä   ‚†ò‚†§‚£Ñ‚£†‚†û‚†Ä\n‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£∑‚°¶‚¢§‚°§‚¢§‚£û‚£Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\n‚†Ä‚¢Ä‚£§‚£¥‚£ø‚£è‚†Å‚†Ä‚†Ä‚†∏‚£è‚¢Ø‚£∑‚£ñ‚£¶‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\n‚¢Ä‚£æ‚£Ω‚£ø‚£ø‚£ø‚£ø‚†õ‚¢≤‚£∂‚£æ‚¢â‚°∑‚£ø‚£ø‚†µ‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\n‚£º‚£ø‚†ç‚†â‚£ø‚°≠‚†â‚†ô‚¢∫‚£á‚£º‚°è‚†Ä‚†Ä ‚†Ä‚£Ñ‚¢∏‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä",
            "‚†Ä‚†Ä‚†Ä‚£†‚£∂‚°æ‚†è‚†â‚†ô‚†≥‚¢¶‚°Ä‚†Ä‚†Ä‚†Ä‚¢†‚†û‚†â‚†ô‚†≤‚°Ä‚†Ä\n ‚†Ä‚£¥‚†ø‚†è‚†Ä‚†Ä‚†Ä‚†Ä   ‚†Ä  ‚†Ä‚¢≥‚°Ä‚†Ä‚°è‚†Ä‚†Ä       ‚¢∑\n‚¢†‚£ü‚£ã‚°Ä‚¢Ä‚£Ä‚£Ä‚°Ä‚†Ä‚£Ä‚°Ä   ‚£ß‚†Ä‚¢∏‚†Ä  ‚†Ä       ‚°á\n‚¢∏‚£Ø‚°≠‚†Å‚†∏‚£õ‚£ü‚†Ü‚°¥‚£ª‚°≤   ‚£ø  ‚£∏   Nikal   ‚°á\n ‚£ü‚£ø‚°≠‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢±‚†Ä       ‚£ø  ‚¢π‚†Ä           ‚°á\n  ‚†ô‚¢ø‚£Ø‚†Ñ‚†Ä‚†Älodu‚†Ä‚†Ä   ‚°ø ‚†Ä‚°á‚†Ä‚†Ä‚†Ä‚†Ä   ‚°º\n‚†Ä‚†Ä‚†Ä‚†π‚£∂‚†Ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä  ‚°¥‚†É‚†Ä   ‚†ò‚†§‚£Ñ‚£†‚†û‚†Ä\n‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£∑‚°¶‚¢§‚°§‚¢§‚£û‚£Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\n‚†Ä‚¢Ä‚£§‚£¥‚£ø‚£è‚†Å‚†Ä‚†Ä‚†∏‚£è‚¢Ø‚£∑‚£ñ‚£¶‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\n‚¢Ä‚£æ‚£Ω‚£ø‚£ø‚£ø‚£ø‚†õ‚¢≤‚£∂‚£æ‚¢â‚°∑‚£ø‚£ø‚†µ‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\n‚£º‚£ø‚†ç‚†â‚£ø‚°≠‚†â‚†ô‚¢∫‚£á‚£º‚°è‚†Ä‚†Ä ‚†Ä‚£Ñ‚¢∏‚†Ä"
        ];

        let currentText = '';
        const sentMessage = await conn.sendMessage(from, { text: currentText }, { quoted: mek });

        for (const asciiMessage of asciiMessages) {
            currentText = asciiMessage;
            await sleep(500);
            const protocolMsg = {
                key: sentMessage.key,
                type: 0xe,
                editedMessage: { conversation: currentText }
            };
            await conn.relayMessage(from, { protocolMessage: protocolMsg }, {});
        }
    } catch (e) {
        reply(`‚ùå *Error!* ${e.message}`);
    }
});
